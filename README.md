# 需求分析

## 需求

### 功能性

1. 支持任意的格点分布
*2. 要有合理的网格分块
2. 支持多种覆盖极点的方式
3. 能处理周期边界（还未考虑）
4. 尽量采用经纬坐标（甚至xy坐标）进行三角化
*5. 各个分块能够存储邻居关系
6. 最终要合成一个完整的三角化（前提：任意网格都能成功三角化）

### 高效性

1. 基于有效区域的负载尽量均衡
3. 需要同时支持进程和线程级的并行
4. 额外开销小：剖分区域长宽比尽量接近于1、剖分出有效区块不能过小
5. 保证计算的高效性
6. 保证通信的高效性

### 正确性

1. 正确的三角化结果：保证并行三角化结果与串行三角化结果完全一致（用第三方软件做比较）
2. 任意情况下都能完成正确的三角化

解决方案：
1. 扩展区域不能跨过极点(还未仔细考虑，极区过小情况)
2. 需要对极区进行旋转时，极区剖分区域不能太大（核心区域纬度绝对值大于45度）
3. 多个格点在极点重叠的情况
4. 当网格分辨率很低、或格点数特别少时，如何实现三角化过程？

## 循环边界处理方法

若网格为全球网格，对原搜索树根节点添加一个父节点，该节点的第一孩子为经度-360～0的网格，第二孩子为经度0～360的网格，第三孩子为经度360～720的网格。为节省内存空间，第一孩子（及其子孙）、第三孩子（及其子孙）均和第二孩子（及其子孙）共享本地格点坐标，在实际使用时坐标值经度需先和自己的经度基值相加。

## 扩展区域不能跨过极点(极区过小情况)

极区过小的情况应当通过控制网格分块最小阈值来避免

#### 2. 难点

1. 如何获得网格范围：用户给定还是自动检测
2. 如何保证极区的扩展区域不超过给定范围
3. 在负载平衡的情况下保证长宽比
4. 扩展区域在不超过给定范围、保证负载平衡的前提下，如何解决极点问题
5. 既满足剖分区域不过大也不过小、能处理极区的需求，又能够满足负载平衡
6. 如何检测极点重叠情况？极点重叠情况下，如何进行剖分？对于无效三角形如何处理？
7. 如何在源代码基础上实现xy坐标的三角化
8. 若进程数很大，如何保证有效区块足够大？
9. 如何检测不同分块之间三角化结果的一致性？当出现不一致时，如何进一步处理？一致时如何合成。三角形检测算法
10. 怎么确定分辨率低、或格点数很少的情况？如何解决这种情况下的三角化情况？
11. 怎么处理东西方向的周期边界
12. 三角化用经纬网格还是球坐标系？

#### 3. 解决方案

- [x] 1. 网格范围由用户给定：无法准确检测是否包含极点
- [x] 2. 极区三角剖分问题  
   - 不含极点或仅含一个极点时：将相应极区旋转，旋转之后的扩展区域不能超过限定范围，需要预定一个极区大小的上限（不包含也需要旋转，因为它跨过了极点）  
	- 含有多个极点的时候：极区不旋转，直接当作经纬网格处理
	- 南极北极独立考虑
- [ ] 3. 在每次扩展时进行检测，若超出给定范围，就将扩展区域限制在给定范围内，同时返回一个信息告知扩展边界已达到最大处
- [x] 4. 保证负载平衡，避免过大额外开销，避免过大块、并能保证进程间三角化结果一致性的**剖分方法**
- [x] 5. 多边形剖分还是圆形剖分：方形剖分额外开销小，边界好管理。
- [ ] 6. 判断+/-90度上是否存在多于2个点。对于重叠的极点也算入剖分区域之内。无效三角形在查找、合并等操作时应当忽略
- [ ] 7. 更改源代码
- [ ] 8. 生成Voronoi图，判断对于不同剖分区域同一个点对应的Voronoi格顶点是否相同；判断对于不同剖分区域同一个点所属的Delaunay三角形是否相同  


# 概要设计

## 总流程

1. 获取用户输入：网格范围（是否包含南北极点）
2. 获取并行信息：进程id、总进程数
3. 检查是否已做过并行三角化，若是，则直接返回；否则进行下一步
4. 进行分块操作，确定本地格点、有效边界，设置极限边界（极区进程的极限边界为预设阈值，其他进程极限边界为剩余区域+极区纬向跨度/2）
5. 扩展有效边界（扩展系数为预设值，需要根据实践调优）
6. 扩展三角化边界（扩展系数为预设值，需要根据实践调优）
7. 若有效边界达到90度（或-90度）同时北（南）极点处的点数小于2，则进行网格旋转。
8. 进行X-Y坐标的三角化。
9. 检查核心区域内的三角形是否都为**内三角形**，以及不同进程的共有边界处的三角形是否都完全一致，若二者均是则继续下一步，否则回到步骤6
10. *在各分块核心区域的重叠处，检查三角化结果是否相同，若有不同应报错退出（难点：各进程如何获取邻接关系。此步骤也可以在下一步中由主进程做）
11. 若需要，则进行分块合并操作。各进程将本地三角化结果输出为顶点坐标的形式，收集到主进程，该进程进行去重、合并操作。



## 分块方法

#### 一、确定候选有效点数

1. 根据进程数，算出平均每个进程的平均点数作为候选平均有效点数。
2. 将候选平均有效点数与最小有效点数阈值进行比较，取两者最大来作为候选平均有效点数。
3. 当存在需要北极区旋转时，计算最大北极区范围内的有效点数，当其小于候选平均有效点数时，将前者设为后者。
4. 当存在需要南极区旋转时，计算最大南极区范围内的有效点数，当其小于候选平均有效点数时，将前者设为后者。

#### 二、确定分块数量

5. 如果候选平均有效点数小于最小有效点数阈值时，分块数量为1，并返回；（两种情况：整个网格特别稀疏、极区只有少部分点）-> 若极点内点数占比很小 -> 只要用户给的网格边界纬度低于90，就不必把极区单独考虑？
6. 否则，如果当前平均候选有效点数与步骤1中根据进程数算出的平均有效点数相同时，分块数量等于进程数量；否则，根据当前平均候选有效点数，重新计算分块数量（向上取整），此时分块数量一定不超过进程数（assert）

#### 三、网格分块（保证长宽比接近1）

7. 未分配进程数 = 总进程数
8. 当存在需要北极区旋转时，选出北极附近平均候选有效点数数量的点，作为一个分块，未分配进程数减1
9. 当存在需要南极区旋转时，选出南极附近平均候选有效点数数量的点，作为一个分块，未分配进程数减1
10. 将未分配进程数分成两部分（均分或相差1），按比例将剩余**格点二分**（横切或纵切，取长宽比趋近于1的那一种），继续对分出来的两部分重新做本步操作，直至最后每部分的进程数均为1时停止，记录每部分的点数及边界经纬度
11. 每个进程确定自己的分块、本地格点。

## 格点二分方法

1. 根据比例预估一个分界线，扫描一次所有点，统计左右两边的点数，若实际点数比和预期比值相差小于一定阈值（预先规定），则记录此时分界线，分割完成。
2. 否则计算出需要转移多少点，对点数较多那一部分继续按照比例确定一个分界线，重复步骤1。  
**注意**：需要边分块同时边建立搜索树，若自己的分块涉及不到另外一块的话，就先暂时不向下做

## 边界扩展方法

**问题**

1. 若某边扩展到最大值后仍有外三角形在核心区域内，会导致步骤8的检查无法通过，此时应该怎么处理 
2. 四个边界格点稀疏不均时，如何扩展使得各方向上扩展的点数相近
3. 边界外扩时如何搜索点

**解决方案**

1. 在扩展边界外加入一个虚点，并加入本地点集内进行三角化，标记好与该点相关的三角形，在输出结果时应除去
2. 引入密度函数 -> 如何快速计算好密度函数：单点稀疏度=与上下左右四点距离的平均值
3. 扩展点搜索方案：基于分块建立的搜索树、邻居关系、从根节点搜索。
4. 建立扩展边界时需要极区的分块，（至少扣除极点）

**步骤**

1. 检查各边是否已经达到最大扩展边界，若已到达，加入一个在该方向上的最大边界外的虚点。
2. 计算其余边界的平均稀疏度（如何确定边界点->上下左右1/10的位置作为边界点）
3. 剩余边界的扩展比例与其稀疏度正相关

```
### 功能性

1. 支持各种各样的网格范围：全球／局地／半球／条带／盖状 
2. 要有合理的网格分块
3. 能处理周期边界（还未考虑）
4. 尽量采用经纬坐标（甚至xy坐标）进行三角化
5. 各个分块能够存储邻居关系
6. 最终要合成一个完整的三角化（前提：任意网格都能成功三角化）

### 高效性

1. 基于有效区域的负载尽量均衡
2. 剖分出有效区块不能过小，过小会引入过多额外开销
3. 需要同时支持进程和线程级的并行
4. 分块时相邻块应当尽量在相同节点内
5. 剖分区域长宽比尽量接近于1
6. 当必须有部分进程需要闲置时，应按策略均匀选择闲置线程
7. 南极北极因为需要做极区旋转，计算量大，应尽量分给单独计算节点做
8. 数据结构的设计应尽可能的保证高效的通信
9. 善用线程级的并行，在不需要粗粒度并行时改为细粒度并行，而不是使其空闲
10. 三角化时保证高效的内存管理，避免频繁申请释放内存造成的性能下降。

### 正确性

1. 扩展区域不能跨过极点(还未仔细考虑，极区过小情况)
2. 需要对极区进行旋转时，极区剖分区域不能太大（核心区域纬度绝对值大于45度）
3. 多个格点在极点重叠的情况
4. 当网格分辨率很低、或格点数特别少时，如何实现三角化过程？
```

# 模块设计

## 计算资源管理模块

**输入**：各进程线程信息（节点名、进程ID、线程ID）、有效计算单元数  

**功能**：  

- 根据节点名对进程线程重新统一编号  
- 根据有效计算单元数筛选合适的计算单元组（计算单元数很小且存在需要旋转处理的极区情况时的处理方式） 
- 根据计算单元编号查找进程线程信息
- 返回总计算单元数
- 返回所有有效计算单元
- 返回当前线程的计算单元相关信息

**数据结构**

```c++
struct Grid_working_info {
    int grid_id;
    bool is_active;
    double workload;
}

struct Thread_info {
    char *hostname;
    int process_id;
    int thread_id;
    int processing_unit_id;
    vector <struct Grid_working_info*> grids_working_info;
    struct Grid_working_info* current_grid_working_info;
}

struct Computing_node {
    char *hostname;
    vector <struct Thread_info*> threads_info;
}

class Processing_unit_mgt {
private:
    vector <struct Computing_node*> computing_nodes;
    struct Thread_info **processing_units;(All threads_info sorted by processing_unit_id)
    int *processing_units_id_actived;
    int component_id;
    
    int num_processing_units;
    int num_processing_units_actived;
    struct Thread_info **current_process_threads_info;(length is number of threads in local process)
    ...
```

**Assert**

1. 节点名长度小于128
2. 进程数、线程数大于0
3. 有效计算单元数大于0
4. 计算单元编号介于0～最大计算单元数之间
5. `len(processing_units_id_actived) == num_processing_units_actived`
6. `len(processing_units) == num_processing_units`

**测试用例**：  

- 节点名：空、相同的节点名、不同的节点名
- 进程数：0、1、4、7、100、各节点具有不同的进程数
- 线程数：0、1、4、7、100、各进程具有不同的线程数
- 有效单元数：远小于、小于、等于、大于总计算单元数

**预期结果**：将进程线程按照节点名统一编号，有效计算单元应均匀分配在各节点中。

**检测方式**：分配情况输出到文件，或输出到屏幕

## 网格分块管理模块

**输入**：原始网格、计算资源管理模块  

**功能**：  

- 网格分块（如何考虑多线程情况）
    - 划分出极区的单独分块  
    - 确定剩余网格分块数（考虑极区进程相关的负载平衡问题）
    - 确定所需计算单元
    - 自适应搜索扩展网格分块管理树：确定需要继续分块时（当前计算单元无孩子 && 当前计算单元集合数大于1 &&（本地计算单元号在当前计算单元集合内 || 当前矩形块范围含有被搜索块）），基于当前矩形块范围和当前计算单元集合，进行网格分块，扩展网格分块搜索树（递归），返回本进程相关分块编号，若存在搜索块，返回搜索块内格点坐标
        - 网格与计算单元协同二分（递归）
        - 更新搜索树
        - 获取当前计算单元号，将当前搜索树节点设为含有当前计算单元号的孩子节点
        - 记录本进程相关计算单元的分块编号／地址
- 扩展边界（如何考虑多线程情况）
    - 初始化或扩大扩展系数
    - 根据扩展系数扩展网格边界
    - 搜索新扩展区域所包含的格点
        - 自适应搜索扩展网格分块管理树
- 极区旋转
    - 检查边界是否符合条件（纬度绝对值大于一定阈值）
    - 进行网格旋转
    - 重新计算网格边界
- 三角化
    - 调用X-Y三角化模块，若本地网格块未旋转，对扩展边界内格点做三角化，若本地网格已旋转，对旋转后边界内的格点做三角化。
- 验证三角化结果是否符合要求（与相邻进程在公共边处的三角化结果是否一致）
    - 获得有效边界上的三角化数据
    - 根据邻居关系，调用通信模块，与相邻网格块边界处的三角化数据进行比较
- 返回本进程分块信息（格点坐标，有效边界、扩展边界）
- 返回原始网格

**Assertion**

- 原始网格不为空
- 计算单元管理模块不为空
- 当前计算单元ID大于等于0
- 计算单元总数 > 1
- 边界合法：最小纬度 <= 最大纬度，经度跨度在0~360之内, 纬度在-90~90之内
- 极区分块边界纬度绝对值大于一定阈值
- 协同二分后的子块点数大于最小阈值
- 在扩展边界做的二叉搜索时，搜索经历的每个二叉树节点代表的网格块都应与搜索块有重叠
- 扩展后的边界“小于等于”原始网格边界
- 每次扩展后，有效区域内三角化结构都与前一次有不同之处
- 边界扩展次数小于一定阈值（保证有限次的扩展）
- 进行网格旋转之前，极区分块边界纬度绝对值大于一定阈值
- 网格旋转完，重新计算网格边界后，有效边界“小于等于”扩展边界
- 是否最小分块阈值在一直增加，但三角化效果还是没有改善
- 计算单元的计算指标任何时候都应大于2或等于0
- 检查分割线在很小的范围内来回摆动的情况

**数据结构**

```c++
struct Grid_search_node {
    struct Grid_search_node *parent;
    struct Grid_search_node *first_child, *second_child, *third_child;
    struct Boundry *kernel_boundry;
    struct Boundry *expanded_boundry;
    struct Boundry *rotated_kernel_boundry;
    struct Boundry *rotated_expanded_boundry;
    double expanding_ratio;
    bool   midline_type;
    double midline_value;
    double *local_cells_coord[2]; (clean after having children)
    int *local_cells_global_index; (kernel + expanded)
    int size_local_kernel_cells;
    
    vector <Grid_search_node *> netghbors;
    vector <int> processing_units_id;
    XY_triangulation_class *triangulation;
}

class delaunay_grid_decomposition_mgt {
    Remap_grid_class *original_grid;
    Processing_unit_mgt *processing_unit_mgr;
    Grid_search_node *search_tree_root;
    Grid_search_node *local_threads_node;
    int *num_local_nodes_per_thread;
    int num_total_nodes;
    int *local_units_id;
    double min_length_single_chunk;
}

struct Boundry {
    double min_lat;
    double max_lat;
    double min_lon;
    double max_lon;
}
```

**测试指标**   

- 搜索树结构正确性，邻接关系正确性  

**测试用例**：   

- 原始网格范围 - 纬向：包含两个极点、包含一个极点、不包含极点
- 原始网格范围 - 经向：循环网格、非循环网格
- 原始网格分辨率：低分辨率、中分辨率、高分辨率
- 总计算单元数：0、1、2、8、11、大于有效计算单元数
- 当前计算单元：在、不在全部有效计算单元内

**预期结果**：

- 网格二分：子网格格点数的比值符合预期、且长宽比接近于1
- 网格分块：极区特殊对待、各子块不小于一定阈值
- 搜索树：树的各节点大小关系正确、邻居关系正确

**检测方式**：输出到文件

## X-Y三角化模块

**输入**：格点坐标、三角化范围（两个经纬边界）  

**功能**：  

- 对边界范围内网格进行X-Y三角化
- 返回有效区域内三角化结果 
- 返回扩展区域内三角化结果
- 返回有效区域边界上的三角化结果

**测试指标** 
 
- 检查每次扩展边界后有效区域内三角形是否发生变化  
- 扩展后边界是否超过阈值  

**检测方式**：程序内部判断

**测试用例**  
 
- 子网格范围：极区、非极区
- 子网格长宽比：1:1、5:1、1:5、10:1、1:10

**预期结果**：生成稳定的三角化结果、各子块重叠区域三角化结果一致

**检测方式**：输出到文件 + 程序内部判断

## 通信模块

**功能**：  

- 向指定个计算单元发送数据  
- 从指定个计算单元获取数据
- 向所有计算单元广播数据

**测试用例**  

- 发送单元与接受单元关系：在同一进程内、在不同进程内、二者皆有

**预期结果**：相同进程内无需使用MPI通信、不同进程内需要用MPI通信

## 球三角化模块（已存在）

**输入**：CoR网格、 三角化范围（经纬边界）  
**功能**：  
- 做出稳定的三角化结果（保证相同点集的输出结果一致）  
- 返回三角化结果 

# 开发流程

1. 计算资源管理模块
    - MPI、OpenMP 
2. 通信模块
    - 进程、线程
3. 网格分块管理模块
4. 将原球面三角化模块改为X-Y三角化模块



```
- 网格点按比例二分（在较少步骤内迭代找到一个可以接受的分割线）  
- 根据总分块数和本地所需分块号，对CoR网格进行不断二分，以确定本地所需分块的信息（index、边界、邻接关系）  
- 在上述分块同时建立搜索树（和本计算单元不相关的另外分支暂不深入）  
- 可扩展的边界，扩展时利用搜索树确定扩展区域内的格点，同时确定本地子块的邻接关系  
- 进程线程均采用统一接口操作分块

- 需要的话，对极区进行网格旋转  
- 判断当前三角化结果是否满足要求
- 做出稳定的三角化结果（保证相同点集的输出结果一致）  
- 三角化的数据结构应有利于进程间通信 


**输出**：计算单元按照主机名的重新编号、有效计算单元ID
**输出**：本地分块边界（有效边界、扩展边界）
**输出**：范围内的网格格点三角化结构  
**输出**：范围内的网格格点三角化结构 

- 节点名／进程数／某进程的线程数 为空或0  
- 节点名只有一种  
- 一半的节点只有一个进程一个线程，同时有效计算单元数小于总单元数  
- 有效计算单元数远小于总进程数 

- 仅有北极或仅有南极  
- 区域网格不包含极点、包含南极或北极、包含两个极点  
- 网格分辨率较小、较大  
- 总分块数为1  
- 总分块数为2，同时网格包含一个或两个极点  
- 总分块数是2的指数倍、不是2的指数倍（二分时需要多次不均等二分的情况）  
- 总分块数很大  
- 本地所需分块号不在可分配范围内  

    - 扩展边界
        - 调用网格分块管理模块的扩展边界
    - 进行极区旋转
        - 调用网格分块管理模块的极区旋转
    - 验证三角化结果是否符合要求（与相邻进程在公共边处的三角化结果是否一致）
```